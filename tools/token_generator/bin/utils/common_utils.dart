part of '../main.dart';

const String _generatedHeader = '''/// ðŸ¤– GENERATED BY token_generator
///
/// maintained by [seunghwanly](github.com/seunghwanly)''';
const String _ignoreForFile =
    '// ignore_for_file: constant_identifier_names, non_constant_identifier_names';

final Set<String> _dartReserved = {
  'assert',
  'break',
  'case',
  'catch',
  'class',
  'const',
  'continue',
  'default',
  'do',
  'else',
  'enum',
  'extends',
  'false',
  'final',
  'finally',
  'for',
  'if',
  'in',
  'is',
  'new',
  'null',
  'rethrow',
  'return',
  'super',
  'switch',
  'this',
  'throw',
  'true',
  'try',
  'var',
  'void',
  'while',
  'with',
  'yield',
  'async',
  'await',
  'covariant',
  'deferred',
  'dynamic',
  'export',
  'extension',
  'external',
  'factory',
  'function',
  'get',
  'implements',
  'import',
  'interface',
  'late',
  'library',
  'mixin',
  'operator',
  'part',
  'required',
  'set',
  'show',
  'hide',
  'static',
  'typedef',
};

class _AtomicGenerationState {
  final Set<String> generatedBasenames = {};
  bool generatedColorLibrary = false;
  final Set<String> generatedColorPartBasenames = {};
  bool generatedFontLibrary = false;
  final Set<String> generatedFontPartBasenames = {};
}

class _SemanticGenerationState {
  bool generatedSemanticColor = false;
  bool generatedSemanticTypography = false;
  bool generatedSemanticShadow = false;
  final Set<String> semanticColorParts = {};
  final Set<String> semanticShadowParts = {};
}

String _pascalCase(String input) {
  final cleaned = input.replaceAll(RegExp('[^A-Za-z0-9]+'), ' ').trim();
  if (cleaned.isEmpty) return '';
  final parts = cleaned.split(RegExp(' +'));
  return parts
      .map((p) => '${p.substring(0, 1).toUpperCase()}${p.substring(1)}')
      .join();
}

String _camelCase(String input) {
  final pas = _pascalCase(input);
  if (pas.isEmpty) return '';
  return '${pas.substring(0, 1).toLowerCase()}${pas.substring(1)}';
}

String _toSnake(String input) {
  final buf = StringBuffer();
  for (int i = 0; i < input.length; i++) {
    final c = input[i];
    if (RegExp('[A-Z]').hasMatch(c)) {
      if (i != 0) buf.write('_');
      buf.write(c.toLowerCase());
    } else if (RegExp('[^a-z0-9]').hasMatch(c)) {
      buf.write('_');
    } else {
      buf.write(c);
    }
  }
  var s = buf.toString();
  s = s.replaceAll(RegExp('_+'), '_');
  s = s.replaceAll(RegExp(r'^_+'), '');
  s = s.replaceAll(RegExp(r'_+$'), '');
  return s;
}

String _identifierFromKey(String key) {
  if (int.tryParse(key) != null) return 'v$key';
  var id = _camelCase(key);
  if (id.isNotEmpty && int.tryParse(id[0]) != null) id = 'v$id';
  return _dartReserved.contains(id) ? '${id}_' : id;
}

int _keyCompare(String a, String b) {
  final (an, bn) = (RegExp(r'^\d+$').hasMatch(a), RegExp(r'^\d+$').hasMatch(b));
  return switch ((an, bn)) {
    (true, true) => int.parse(a).compareTo(int.parse(b)),
    (true, false) => -1,
    (false, true) => 1,
    _ => a.toLowerCase().compareTo(b.toLowerCase()),
  };
}

String _getDartTypeForToken(String type) => switch (type) {
  'color' => 'Color',
  'dimension' ||
  'number' ||
  'fontSize' ||
  'fontSizes' ||
  'lineHeight' ||
  'letterSpacing' => 'double',
  'text' => 'String',
  'boxShadow' => 'List<BoxShadow>',
  _ => 'String',
};

bool _hasFontRootKey(Map<String, dynamic> jsonMap) {
  return jsonMap.keys.whereType<String>().any((k) => k.toLowerCase() == 'font');
}

String _inferDominantType(Map<String, dynamic> node) {
  final typeCounts = <String, int>{};

  void walk(dynamic n) {
    switch (n) {
      case Map<String, dynamic> map
          when map.containsKey(r'$type') && map.containsKey(r'$value'):
        final type = map[r'$type'] as String;
        typeCounts[type] = (typeCounts[type] ?? 0) + 1;
      case Map<String, dynamic> map:
        for (final v in map.values) {
          walk(v);
        }
    }
  }

  walk(node);

  if (typeCounts.isEmpty) return 'mixed';

  return typeCounts.entries.reduce((a, b) => a.value > b.value ? a : b).key;
}
